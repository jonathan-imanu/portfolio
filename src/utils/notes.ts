/*
  Notes index and note retrieval utilities that support lazy loading of notes.
  The notes index is a JSON file that contains the metadata for all notes.
  It is automatically generated by a GitHub Actions workflow.
*/

import type { ProcessedNote, NoteMetadata, NotesIndex } from "../types/notes";

let indexCache: NotesIndex | null = null;
let indexPromise: Promise<NotesIndex> | null = null;

async function loadNotesIndex(): Promise<NotesIndex> {
  if (indexCache) {
    return indexCache;
  }
  if (indexPromise) {
    return indexPromise;
  }
  indexPromise = import("../data/notes-index.json").then((module) => {
    indexCache = module.default as NotesIndex;
    return indexCache;
  });
  return indexPromise;
}

// Lazy load individual notes
export async function getNote(id: string): Promise<ProcessedNote | undefined> {
  try {
    const module = await import(`../data/notes/${id}.json`);
    return module.default as ProcessedNote;
  } catch (error) {
    console.error(`Note ${id} not found:`, error);
    return undefined;
  }
}

export async function getAllNotesMetadata(): Promise<NoteMetadata[]> {
  const index = await loadNotesIndex();
  return Object.values(index.notes);
}

export async function getNotesIndex(): Promise<NotesIndex> {
  return loadNotesIndex();
}

// Tree structure types
export interface TreeNode {
  name: string;
  fullPath: string;
  children: Map<string, TreeNode>;
  note?: NoteMetadata;
  isLeaf: boolean;
}

// Build a tree structure from notes
export function buildNotesTree(notes: NoteMetadata[]): TreeNode {
  const root: TreeNode = {
    name: "",
    fullPath: "",
    children: new Map(),
    isLeaf: false,
  };

  for (const note of notes) {
    const parts = note.path.split("/");
    let current = root;

    for (let i = 0; i < parts.length; i++) {
      const part = parts[i];
      const isLast = i === parts.length - 1;
      const fullPath = parts.slice(0, i + 1).join("/");

      if (!current.children.has(part)) {
        current.children.set(part, {
          name: part,
          fullPath,
          children: new Map(),
          isLeaf: isLast,
          note: isLast ? note : undefined,
        });
      }

      current = current.children.get(part)!;
      if (isLast) {
        current.note = note;
        current.isLeaf = true;
      }
    }
  }

  return root;
}

// Get breadcrumbs from a note path
export function getBreadcrumbs(
  path: string
): Array<{ name: string; path: string }> {
  const parts = path.split("/");
  const breadcrumbs: Array<{ name: string; path: string }> = [];

  for (let i = 0; i < parts.length; i++) {
    const pathSegment = parts.slice(0, i + 1).join("/");
    breadcrumbs.push({
      name: parts[i],
      path: pathSegment,
    });
  }

  return breadcrumbs;
}

// Natural sort comparator that handles numeric prefixes correctly
// e.g., "2. TITLE" should be sorted before "11. TITLE", or "2-text" before "11-text"
export function naturalCompare(a: string, b: string): number {
  // Match numeric prefix followed by period, space, or hyphen
  const numMatchA = a.match(/^(\d+)(\.\s|-)/);
  const numMatchB = b.match(/^(\d+)(\.\s|-)/);

  // If both have numeric prefixes, compare numerically
  if (numMatchA && numMatchB) {
    const numA = parseInt(numMatchA[1], 10);
    const numB = parseInt(numMatchB[1], 10);
    if (numA !== numB) {
      return numA - numB;
    }
    // If numbers are equal, compare the rest of the string
    const restA = a.slice(numMatchA[0].length);
    const restB = b.slice(numMatchB[0].length);
    return restA.localeCompare(restB);
  }

  // If only one has a numeric prefix, put it first
  if (numMatchA && !numMatchB) {
    return -1;
  }
  if (!numMatchA && numMatchB) {
    return 1;
  }

  // Neither has a numeric prefix, use standard string comparison
  return a.localeCompare(b);
}

{
  "id": "dev--languages--python--fluent-in-python--4-control-flow--17-iterators-generators-and-classic-coroutines",
  "path": "dev/languages/python/fluent-in-python/4-control-flow/17-iterators-generators-and-classic-coroutines",
  "title": "17. Iterators, Generators, and Classic Coroutines",
  "content": "# Iterators\n\nPython automatically calls `iter(x)` when trying to iterate over a function. The `iter` built-in checks if `__iter__` is implemented, if not then gets creates an iterator with `__getitem__`. If that isn't implemented, then we get a type error.\n\n```python\ndef d6():\n\treturn randint(1, 6)\n\nd6_iter = iter(d6, 1) # 1 is sentenial val, stop when 1 is reached\nfor roll in d6_iter:\n\tpass\n\n# d6_iter is useless here\n# the iterator is exhausted \n```\n\n## Iterators vs Iterables\n\nIterables have an `__iter__` method that instantiates a new iterator every time. Iterators implement a `__next__` method that returns individual items, and an `__iter__` method that returns `self`.\n\n**Iterables produce iterators**\n# Generators\n\nAny Python function that has the `yield` keyword in its body is a generator function: a function which, when called, returns a generator object. \n\nIn other words, a generator function is a generator factory.\n\n*Generator objects implement the Iterator interface, so they are also iterable.* The return statement in the body of a generator function causes `StopIteration` to be raised by the generator object\n\n### `yield from`\n\nAllows us to yield values produced by another generator.\n\n```python \ndef generate(n: int, i: int, cur: list[int]):\n    if i == n:\n        yield cur\n        return\n\n    for x in generate(n, i + 1, cur + [i]):\n        yield x\n\n    for x in generate(n, i + 1, cur + [i + 1]):\n        yield x\n\n# Becomes the cleaner and simplier:\n\ndef generate(n: int, i: int, cur: list[int]):\n    if i == n:\n        yield cur\n        return\n\n    yield from generate(n, i + 1, cur + [i])\n    yield from generate(n, i + 1, cur + [i + 1])\n```\n\n**Google Interview Lesson:**\n\nAs the above example demonstrates, backtracking or other recursive functions where in which we don't care about the complete result set are excellent cases for which to use generators.\n\nAt the end of the day, generators are just special iterators that:\n\n- produce values lazily\n- have execution state suspended and resumed between yields\n\nThe key consequences of this are:\n\n1. Only the **current call stack**\n2. Only the **current path**\n3. Only the **current iterator states**\n\n# Classic Coroutines / Generator-Based Coroutines\n\n**Coroutine General Definition:** A coroutine is a function-like routine that can pause its execution (yield) at specific points, preserving its state, and then be resumed later from that exact spot.\n\nA coroutine is really a generator function, created with the yield keyword in its body. And a coroutine object is physically a generator object.\n\nTyping of a coroutine: `Coroutine[YieldType, SendType, ReturnType]`\n\nProbably worth fully reading https://peps.python.org/pep-0342/ if we ever encounter this in the wild.\n\nWith these generator based coroutines, we'll have to call `next()` first.\n",
  "metadata": {
    "date": "2026-01-16",
    "updated": "2026-01-16"
  },
  "images": [],
  "links": []
}
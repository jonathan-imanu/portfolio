{
  "id": "leetcode--concepts--graphs--topological-sort",
  "path": "leetcode/concepts/graphs/topological-sort",
  "title": "Topological Sort",
  "content": "# TLDR\n\nThe **topological sort** algorithm takes a directed graph and returns an array of the nodes where each node appears _before_ all the nodes it points to.\n\nIt's sorting based on in-degree of nodes. Cyclic graphs will not have a valid topological sort.\n# Kahn's Topological Sort\n\n**Kahn's Algorithm** works by repeatedly finding vertices with no incoming edges, removing them from the graph, and updating the incoming edges of the vertices connected from the removed removed edges. This process continues until all vertices have been ordered.\n\nUse a queue to track nodes that got brought to 0\n\n```python\ndef kahn_topo_sort(graph: dict[int[List[int]]]) -> List[int]:\n\tindegrees = defaultdict(int)\n\tfor node, neighbours in graph.items():\n\t\tif node not in indegrees:\n\t\t\tindegrees[node] = 0\n\t\tfor neighbour in neighbours:\n\t\t\t\n\t\t\tindegrees[neighbour] += 1\n\t\n\tq = deque()\n\tfor node, count in indegrees:\n\t\tif count == 0:\n\t\t\tq.append(node)\n\t\n\tresult = []\n\twhile q:\n\t\tnode = q.popleft()\n\t\tfor neighbour in graph[node]:\n\t\t\tindegrees[neighbour] -= 1\n\t\t\tif indegrees[neighbour] == 0:\n\t\t\t\tq.append(neighbour)\n\t\tresult.append(node)\n\t\n\treturn result\n```\n\n",
  "metadata": {
    "date": "2026-01-16",
    "updated": "2026-01-16"
  },
  "images": [],
  "links": []
}
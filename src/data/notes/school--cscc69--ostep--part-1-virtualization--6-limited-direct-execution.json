{
  "id": "school--cscc69--ostep--part-1-virtualization--6-limited-direct-execution",
  "path": "school/cscc69/ostep/part-1-virtualization/6-limited-direct-execution",
  "title": "6. Limited Direct Execution",
  "content": "> Consider the time-sharing virtualization model presented in [4. The Process](/notes/4-the-process):\n>  - How would we implement this without adding excessive system overhead?\n>  - How can we (the OS) run processes efficiently whilst maintaining control over the CPU?\n\nTLDR: The OS baby-proofs the CPU with trap handlers and an interrupt timer. The babies are processes.\n#### The Basics of LDE\n\nThe simple approach of just \"Run the program directly on the CPU\" means we don't actually have control of anything and work more like a library than an actual OS.\n\nHere are the problems:\n1. Restricted Operations can be performed\n2. Switching between processes\n\t1. How can the OS switch between processes if it doesn't have control of the CPU\n##### 1. Allowing Processes to run Restricted Operations Whilst Maintaining Control\n\n- Run processes in `user mode` by default\n\t- In contrast, we (the OS) run in `kernel mode`\n\t\t- `Kernel mode` means that OS has full access to hardware\n\t\t- `User mode` means that program does not have full access to hardware\n- To perform some privileged operation, processes can use *system calls* \n\t- Uses the `trap` and the `return-from-trap` instructions mentioned in [Introduction to Operating Systems](/notes/introduction-to-operating-systems)\n\t- To avoid clobbering the calling processes registers, on x86, the processor pushes PC, flags and some registers into a per-process kernel stack. The `return-from-trap` restores these\n\n> The `trap` raises another issue: *How do we know what code is to run inside of the OS?*\n\nThe solution is a **trap table** set up by the kernel at boot time (when a machine boots up it's in `kernel mode`.\n##### 2. Switching Between Processes\n\n**Cooperative Approach**:  The OS \"trusts\" the process to behave reasonably. A process would transfer control by making system calls or when they do something illegal.\n- Used by older systems\n- Has the obvious drawback that evil processes can just hold on to the CPU forever\n**Non-Cooperative Approach**: Use *timer interrupts* that raise every so many milliseconds so that, when raised, a pre-configured *interrupt handler* in the OS can run and regain control of the CPU\n- Similar to the `trap` and `return-from-trap` we have to avoid clobbering the registers and state of the currently running program so that we can easily resume\n\nAfter we regain CPU control, we can either switch to a new process or continue running the current one (this is decided by the OS's scheduler).\n\nIf we switch, OS executes a **context-switch**:\n1. Save the register values for the currently executing process into kernel stack\n2. Restore register values for the soon to be executing process\nNow when we `return-from-trap`, the new switched in process starts\n\n\n\n\n\n\n\n\n",
  "metadata": {
    "date": "2026-01-16",
    "updated": "2026-01-16"
  },
  "images": [],
  "links": [
    "4-the-process",
    "introduction-to-operating-systems"
  ]
}
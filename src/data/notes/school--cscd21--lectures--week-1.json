{
  "id": "school--cscd21--lectures--week-1",
  "path": "school/cscd21/lectures/week-1",
  "title": "Week 1",
  "content": "# Cryptography Toolbox\n\n### Hashing\n\nWe say that $H(m) = x$ is a hash function if:\n- $m$ is a message of any length\n- $x$ is a message digest of a fixed length\n- $H$ is a non invertible function\n\t- $H$ is a lossy compression function, necessarily $\\exists m_1, m_2$ such that $H(m_1) = H(m_2)$\n\nIt's of course straight-forward (either polynomial or linear) to find $x$ given $H$ and $m$.\n- Given $H$ is collision resistant, it's said to be *computationally-intractable* for one to find $m$ and $m'$ such that $H(m) = H(m') = x$\n### Commitment Scheme\n\nA **cryptographic commitment** is a primitive that lets a party fix a value now while keeping it hidden, and reveal it later in a way that is verifiable.\n- Can think of it as the digital equivalent of a sealing a value in an envelope.\n\nBroken down into two phases:\n1. Commit: `x = commit(m)`\n\t1. Commitment $x$ requires a fixed and minimal storage\n\t2. Commitment $x$ alone does not reveal the content of $m$. We say it is non-reversible.\n2. Reveal and Verify: `verify(x, m) = true`\n\t1. There are no collisions.\n### Merkle Trees\n\n[Good Article](https://decentralizedthoughts.github.io/2020-12-22-what-is-a-merkle-tree/#fn:handwave)\n\n**Goal**: We want to commit several values as one commitment and show that a value belongs to a collection.\n- Naively we can do this by committing $m_0, \\ldots, m_n$ but we then need this entire collection to verify that some $m_i$ is indeed a part of the collection.\n\nMerkle Trees allow us to validate that some value $m_i$ belongs to some collection $m_0, \\ldots, m_n$ without knowing the collection after the commitment!\n\nIt follows the list commitment scheme:\n1. Phase 1: `x = commit(m1, m2, ..., mn)`\n\t1. `x` is the Merkle Root\n2. Phase 2: `verify(x, mi, pi) = true`\n\t1. In the naive implementation, `pi` (the proof) would have needed to have been the entire collection. \n\t2. In this case, it's just a **Merkle Proof** which is of size `log_2(n)`\n### Digital Signatures\n\nA key pair consists of a public key $pk_A$ and a secret key $sk_A$. The idea is that the public key can be distributed freely to anyone and they can use it verify a message $m$ signed by the public key.\n- It's very hard to find matching secret key given a private key and to forge a signature without knowing the secret key.\n\n",
  "metadata": {
    "date": "2026-01-16",
    "updated": "2026-01-16"
  },
  "images": [],
  "links": []
}
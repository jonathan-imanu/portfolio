{
  "id": "dev--languages--cpp--a-tour-of-c-stroustrup-2014--4-classes",
  "path": "dev/languages/cpp/a-tour-of-c-stroustrup-2014/4-classes",
  "title": "4. Classes",
  "content": "**void memberFunction() const;** means that memberFunction will not modify the modify that it is called on.\n\n**In constructors, all base classes and data members are fully initialized before the constructor body runs.**\n### Destructors\n\nA way to deallocate memory for classes\n\n```cpp\nclass Toy {\nprivate:\n\tdouble* elem;\n\tint sz;\npublic:\n\tToy(int size) :elem{ new double[s]}, sz{size}\n\t{\n\t\t// init elem\n\t}\n\t~Toy() { delete []elem; } // <- the destructor\n};\n```\n\n**The technique of acquiring resources in a constructor and releasing them in a destructor, known as Resource Acquisition Is Initialization or RAII**\n### Concrete Types \n\nBehave just like built-in types. The `Toy` class above is a good example of a concrete type.\n### Abstract Types \n\nKinda like interfaces and abcs\n\n```cpp\nclass Container {\npublic:\n\tvirtual double& operator[](int) =0;\n\tvirtual int size() const = 0;\n\tvirtual ~Container() {}\n}\n```\n\n`=0` means **pure virtual** meaning that a class derived from Container must define the function.\n\n**It is the pure virtual function that makes Container abstract**\n\nAn class derived from Container would look like:\n\n```cpp\nclass VectorContainer : public Container {\n\t// ...\n} \n```\n\nThis type of structure lends itself nicely to polymorphism.\n\n##### Difference between virtual and pure virtual\n\n**Virtual**: A child class may override this and the base provides a default implementation\n\n**Pure Virtual**: If a class contains a PV it can't be instantiated. PV don't have default implementations and child class MUST override. \n##### Virtual Function Table (vtbl)\n\nConsider:\n\n```cpp\nclass PureVirtual { \npublic:\n\tvirtual void func1() const =0;\n}\nclass Child1 : public PureVirtual {\n\t// implements func1()\n} \nclass Child2 : public PureVirtual {\n\t// implements func1()\n}\n\nvoid use(&PureVirtual pv) {\n\tpv.func1();\n\treturn;\n}\n```\n\nIf you call `use()` with a `Child1` how would it know which function to call when it only sees the abstract class?\n\nEnter vtbl: The compiler will convert the name of a virtual function into an index into a table of pointers to functions. \n\nThe vtbl allows the virtual function call mechanism to be made almost as efficient as a 'normal' function call. \n\nThere is a space overhead of one pointer in each object of a class with virtual functions AND 1 vtbl for each such class.\n\n#### Copying & Moving Containers\n\nObjects can be copied by default. They will be member wise copied. \n\nWe can choose the semantics of copying though. In particular, for classes that control a object accessed through a pointer the default memberwise copy would led to funky behavior. \n\n```cpp\n...\nclass Something {\npublic:\n\t// Copying\n\tSomething(const Something &smth);\n\tSomething& operator=(const Something& smth);\n\t\n\t// Moving\n\tSomething(Something &&smth);\n\tSomething& operator=(Something&& smth)\n\t\n};\n```\n\n#### Aside: const as a type augment\n\nUse when you don't need to modify the object passed to function. There are two ways to do this:\n\n```cpp\nvoid function(const SomeType s); // Copies s, function never sees the og SomeType\nvoid function(const &SomeType s); // Passes a reference to s\n```\n\n#### &&: 'rvalue reference'\n\n'rvalue' is a term intended to complement 'lvalue' which means something that can appear on the left-hand side of an assignment.\n\nThere are five situations in which an object is copied or moved: \n\n1. As the source of an assignment \n2. As an object initializer \n3. As a function argument\n4. As a function return value \n5. As an exception \n\nIn all cases, the copy or move constructor will be applied (unless it can be optimized away). In addition to the initialization of named objects and objects on the free store, constructors are used to initialize temporary objects and to implement explicit type conversion\n\n### Suppressing Operations\n\nUsing the default version of copy or move in a derived class might not be what we want or if we want to prevent a child from accessing a method defined in a parent class:\n\n```cpp\nclass Child1 {\npublic:\n\tChild1(const Child& c) =delete; \n};\n```\n\n`=delete` is what deletes the op\n\n\n\n\n\n\n\n`",
  "metadata": {
    "date": "2026-01-16",
    "updated": "2026-01-16"
  },
  "images": [],
  "links": []
}
{
  "id": "school--cscd21--lectures--week-2",
  "path": "school/cscd21/lectures/week-2",
  "title": "Week 2",
  "content": "#  Blockchains\n### Centralized Ledger\n\n- Used by traditional banking systems. The bank is the trusted third party. \n## Decentralized Ledger (over a P2P network)\n\n- All nodes have a copy of the ledger and ensure local correctness\n\n**Pros:**\n- No single point of failure\n- Better reliability since network can handle some nodes going down\n- Better security since some nodes can be malicious but the rest of the network has legitimate ledger\n**Cons:**\n- Harder to authenticate users\n- Consistency is harder because of P2P\n\nWe use public-key cryptography and a digital signature where:\n- The public key is the identity\n- The signature is the authentication mechanism\n\n### Solving Consistency Problems\n\n##### Naive - Flood Routing Algorithm\n\nWhen receiving a transaction, forward it to all connected peers. \n- A transaction will take time to broadcast on the network and during that time an attacker can do a **double spending attack**\n\n**Double Spending Attack**: Broadcasting two conflicting transactions to distant nodes in the network.\n## Blockchain Solution\n\nHave the network \"agree\" at some set interval about some snapshot of the valid transactions so far. This snapshot is called a *block*.\n- All transactions are verified and accepted into a *mempool* of unconfirmed transactions \n- Every $t$ seconds, \"the network selects one node\" to create a block of confirmed transactions \n- The block is chained to the previous one \n- That block is broadcasted to the network and each node checks whether this block is valid\n###### What is a mempool?\n\nAn abbreviation for \"memory pool.\" A mempool is a temporary holding area for unconfirmed transactions. \n\n1. Transaction is sent from a Bitcoin wallet\n2. Transaction enters the mempool\n3. A Bitcoin miner picks up the transaction from the mempool and includes it in a new block. \n\t1. Miners are responsible for verifying transactions and bundling them into blocks, which are then added to the blockchain.\n\n**A remaining problem:** Figuring out how the network should agree on which node should create and broadcast the block. \n### Types of Blockchains\n\n[Reference](https://www.nervos.org/knowledge-base/utxo_vs_account_based)\n\nBank transactions (account-based) vs. cash transactions (UTXO model).\n#### Account-based Blockchains\n\nIn traditional bank transfers, money transfers are recorded as debits and credits on different users' accounts on the bank's ledger.\n\nAccount-based blockchains do the exact same thing but with a ledger distributed across many nodes. \n\n**Don't track coins but track balance changes**\n- There is a notion of identity\n- One user is associated with a single blockchain account or address\n\nTransactions must be processed sequentially. \n#### Coin-based Blockchains (UTXO)\n\n**UTXO**: Unspent Transaction Output\n\nWorks like cash, the ledger's state is represented by a set of UTXOs. Each UTXO is an indivisible unit of cryptocurrency that can be spent in future transactions.\n\nEach UTXO is associated with a specific owner's public key and can only be spent by providing a valid signature corresponding to that public key.\n\nTransactions consist of inputs and outputs. Where:\n- Inputs are the existing UTXOs that are consumed\n- Outputs are the outstanding unspent coins. These are generated by the transaction. \n\nAllows for the parallel processing of transactions.\n\nNo concept of on-chain identity. \n# Key Management with Crypto Wallets\n\n## ECC\n\n[Reference](https://blog.cloudflare.com/a-relatively-easy-to-understand-primer-on-elliptic-curve-cryptography/)\n##### TLDR\n\n**Elliptic Curve Cryptography (ECC)** is the next generation of public key cryptography and, based on currently understood mathematics, provides a significantly more secure foundation than first generation public key cryptography systems like RSA.\n- ECC is what's used to prove ownership of bitcoins\n\n**Trap Door Functions**: A set of algorithms that is easy to process in one direction, but difficult to undo. The foundation of a good public key cryptography system.\n#### RSA \n\nIn RSA, this maximum value (call it _max_) is obtained by multiplying two random prime numbers. The public and private keys are two specially chosen numbers that are greater than zero and less than the maximum value, call them _pub_ and _priv_. To encrypt a number you multiply it by itself _pub_ times, making sure to wrap around when you hit the maximum. To decrypt a message, you multiply it by itself _priv_ times and you get back to the original number.\n\n## Seeds and Mnemonic Codes\n\nGenerate a private key from a mnemonic seed phrase. Each word comes from a wordlist of 2048 words with some useful properties to make memorizing sentences easier.\n\n\n\n\n",
  "metadata": {
    "date": "2026-01-19",
    "updated": "2026-01-19"
  },
  "images": [],
  "links": []
}
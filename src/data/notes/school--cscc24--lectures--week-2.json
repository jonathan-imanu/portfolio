{
  "id": "school--cscc24--lectures--week-2",
  "path": "school/cscc24/lectures/week-2",
  "title": "Week 2",
  "content": "# Grammars\n\n*A good chunk of this week was review from weeks 7 & 8 of b36. Didn't take notes on those slides, refer to b36-review*\n\nRemember from B36, that **grammars** generate a language.\n### Regular Grammars\n\nMore restrictive than CFGs. They are limited to productions of the form:\n\n- **Left-recursive Grammar**: At most one non-terminal and it appears as the left-most symbol in the string on the RHS of the production rule.\n\n```\n<S> ::= <T> a b\n<T> ::= a | <T> b\n```\n\n- **Right-recursive Grammar**: At most one non-terminal and it appears as the right-most symbol in the string on the RHS of the production rule\n\n```\n<S> ::= a <T>\n<T> ::= b <T> | a b\n```\n\n### Extended BNF\n\nThe CFGs we've encountered are in **Backus-Naur Form**. There are extensions to BNF that make it more concise BUT NOT more powerful.\n- EG `[ blah ]` denotes that `blah` is optional\n- There is no standard EBNF\n### derivation\n\n*Also B36 review*\n\nA derivation of string $s$ is the sequence of applications of production rules that generate $s$.\n- A string is in the language generated by a grammar iff there is a derivation for it\n### Parse Tree\n\nA **parse tree** is a tree in which:\n- the root is the start symbol\n- every leaf is a terminal, and\n- every internal node is a non-terminal, and its children correspond, in order, to the RHS of one of its productions in the grammar.\n\nIf we have multiple parse trees for a given string then we have an ambiguous language. \n## Ambiguity\n\nA grammar is ambiguous iff it generates a string for which there are two or more distinct parse trees.\n\nA string is ambiguous with respect to a grammar iff that grammar generates two or more distinct parse trees for the string.\n\n**Tutorial Comment:** *A red flag for ambiguity in CFG's is one production becoming two of itself.*\n- IE: `A ::= A op A`\n### Adding Precedence\n\nWhen changing a grammar to include precedence, we want the operations with lower precedence to appear closer to the root of the parse tree. Higher precedence operations should appear closer to the leaves.\n##### How to actually do this?\n\nWe can do this with \"chaining\" the weaker ops to the next stronger one:\n\n```\n<expn> --> <expn> <add-op> <expn> | <mult-exp>\n<mult-exp> --> <mult-exp> <mult-op> <mult-exp> | <pow-exp>\n<pow-exp> --> <pow-exp> ^ <pow-exp> | <br-exp>\n<br-exp> --> (<expn>) | <simple>\n<simple> --> <identifier> | <literal>\n<add-op> --> + | -\n<mult-op> --> * | /\n```\n\nNotice how addition \"chains\" to multiplication which then \"chains\" to power and so on.\n- **This is an incorrect grammar since it isn't associative** \n###### Generalizing\n\nWe can describe this as:\n\n```\n<start> ::= <start> weakest-op <start> | <2nd-ws>\n<2nd-ws> ::= <2nd-ws> 2nd-weakest-op <2nd-ws> | <3rd-ws>\n...\n<strongest-symbol> ::=<strongest-symbol> strongest-op <strongest-symbol> | <terminals>\n```\n\nOf course, this grammar is still ambiguous because of associativity issues (How does one parse `<terminal> weakest-op <terminal> weakest-op <terminal>`) even though we didn't say anything about associativity in this example!\n\nA safe fix is to just apply the left or right associativity rule mentioned below. \n\n```\n<start> ::= <start> weakest-op <2nd-ws> | <2nd-ws>\n<2nd-ws> ::= <2nd-ws> 2nd-weakest-op <3rd-ws> | <3rd-ws>\n...\n<strongest-symbol> ::= <strongest-symbol> strongest-op <terminals> | <terminals>\n```\n### Adding Associativity\n\nFor left-associative operators, put the recursive term before the non-recursive term in a production rule. For right-associative operators, put it after.\n##### Example\n\nWe have three operators and terminals defined under `<terminal>`. Suppose the weakest and middle operators are left-associative and the strongest operator is right-associative.\n\n```\n<start> ::= <start> weakest-op <mid-s> | <mid-s>\n<mid-s> ::= <mid-s> middle-op <strongest-s> | <strongest-s>\n<strongest-s> ::= <terminal> strongest-op <strongest-s> | <terminal>\n```\n# Bonus - Chomsky Hierarchy\n\nA linguist who created a hierarchy that ordered languages by expressiveness:\n\n1. Regular Grammars\n2. CFGs\n3. Context-Sensitive Grammars\n4. Phrase-Structure Grammars\n\n\n",
  "metadata": {
    "date": "2026-02-11",
    "updated": "2026-02-11"
  },
  "images": [],
  "links": []
}
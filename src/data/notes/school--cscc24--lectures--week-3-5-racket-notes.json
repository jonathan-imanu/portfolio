{
  "id": "school--cscc24--lectures--week-3-5-racket-notes",
  "path": "school/cscc24/lectures/week-3-5-racket-notes",
  "title": "Week 3-5 Racket Notes",
  "content": "# Racket\n\n[Ref](https://lips.js.org/docs/scheme-intro/data-types)\n\nIn Lisp, everything is written as S-Expression, which is a list wrapped in parentheses with space between elements. \n\n```\n(+ 1 2 3)\n```\n\nwhere `+` is the procedure applied. \n\nIn Scheme, a **procedure** is a _first-class value_ that can be **applied** to zero or more arguments.\n- `+` & `*` on an empty S-expression will default to a the additive and multiplicative identity. \n\nEverything we could every want to do is an expression. These expressions are evaluated by *substitution.* \n- An expression is reduced to a value by repeatedly finding the leftmost expression ready for substitution (all arguments are values) and replacing it with its value. \n\nUse quotes like \n\n```scheme\n`(1 2 4)\n'here\n```\n\nto denote actual data.\n#### Variables\n\n```scheme\n(define x 10)\n```\n#### How Lists/Pairs Work\n\nA pair is just a structure with two fields. `cons` is it's constructor. \n- The procedure `car` can be used to get the first field & `cdr` can be used to get the second field. \n\n```scheme\n; cons is a checked constructor that can create two-field instances\n; a & b can be literally anything\n(cons a b)  \n```\n\nA list is basically a pair BUT the last element of every pair must be a list. Everything starts from the empty list (which isn't a pair) \n\n```scheme\n`() ; the empty list\n```\n#### Conditionals\n\n```scheme\n; if statement\n; syntax: (if cond-expr then-expr else-expr)\n(if (= 4 5) 1 2) ; returns 1\n\n; a more powerful conditional\n; (cond \n;\t[cond1-expr then1-expr]\n;\t...\n;\t[condN-expr thenN-expr]\n;\t[else else-expr])\n(cond\n\t[(= 4 5) (error \"this can't happen\")]\n\t[else 'here])\n\t\n; we also have the following procedures:\n; - and\n; - or\n; - not \t\n```\n#### Functions\n\n```scheme\n; Named\n(define (function-name arg1 ... argn)\n\t(function-body))\n\n; Anonymous Functions\n(lambda (lambda-args) (lambda-body))\n```\n\n##### An Example of how to Design a Tail Recursive Function\n\n```scheme\n(define (my-length xs)  ; return length[xs]\n  (local [(define (helper xs acc)  ; return length[xs] + acc\n            (if (empty? xs) acc\n\t            (len-t (rest xs) (+ acc 1))))]\n    (len-t xs 0)))\n```\n\n### Higher-Order Procedures\n\n#### Map\n\n```\n(map proc l1 .. ln)\n```\n\nwhere `l1 ... ln` are all lists of the same size.\n\nApply `proc` to every position.\n- EX: `(map + '(1 2 3) '(2 3 4) '(3 4 5)) -> (6 9 12)`\n#### Apply\n\n```\n(apply op lst)\n```\n\nwhere:\n- `op` is an `n`-ary proc\n- `lst` is a list of `n` args to `op`\n\nWe just apply op to the list. This is a lot like `op.apply(null, lst)` in JavaScript.\n#### Fold\n\n```\n(foldr op id lst)\n(foldl op id lst)\n```\n\nwhere:\n- `op` is a binary procedure\n\t- This just a function that takes two arguments\n- `id` is the identity element\n\t- We don't actually need to supply the identity element. It's not like it's checked.\n- `lst` is a list of arguments\n\nA better way to think of it is: `(fold op acc lst)` \n1. It is a function that traverses a list in a specified direction \n2. It will store the result of `(op first-elem (or last-elem) acc)` into `acc` and continue until everything has been consumed\n3. At the end, `acc` will be what is returned\n### Parameter Lists\n\nBind a procedure value to a name and validate arity (argument size) at runtime:\n\n```scheme\n(define f (lambda (x) (+ x 10)))\n```\n\nThis is equivalent in functionality to:\n\n```scheme\n(define (f x) (+ x 10))\n```\n\nWe also have variadic lists and the optional to specify mandatory arguments and non-mandatory arguments:\n\n```scheme\n(required-params . rest-param)\n```\n\n## Evaluation and Continuations \n\nAny expression that isn't a value can always be partitioned into two parts:\n1. a **redex** (\"reducible expression\")\n2. the **continuation**, which is the evaluation context around the redex\n\t1. Can be thought of as what needs to be done in order to complete the evaluation\n\n> Given a well-formed Racket program, every well-formed sub-expression in this program corresponds to a point in the evaluation of the program, and every such point corresponds to a continuation\n#### An Example\n\n`(+ (* 3 5) (- 10 3))`\n\nThe continuation of `(* 3 5)` would be `(+ [] (- 10 3)`. \n- The reason it isn't `(+ [] (- 10 3))` even though we know Racket evaluates these sub-expressions from right-to-left is because continuations are about **semantic** context NOT evaluation order.\n\nA continuation is really: \n\n> The rest of the computation, _as a function of the value of_ _E_.\n\nSo it is more apt to say that the continuation of the above example is:\n\n`(lambda (E) (+ E (- 10 3)))`\n\n**Continuations are first-call values.**\n\nConceptually we think of everything as being a continuation. \n- The current continuation can be reified as a function by using the built-in function call-with-current-continuation (or call/cc for short)\n### Continuation-Passing Style (CPS)\n\nKind of like tail-recursion but we pass a function instead of having an accumulator. This has the effect of passing control forward rather than the data. \n\nJust like how we start with the identity element as the accumulator for tail-recursion, we use the identity function for CPS.\n\nAs far as the stack is considered, since all calls to continuations are tail calls they are optimized away by Racket.\n",
  "metadata": {
    "date": "2026-02-11",
    "updated": "2026-02-11"
  },
  "images": [],
  "links": []
}
{
  "id": "leetcode--notes--daily--2106-maximum-fruits-harvested-after-at-most-k-steps",
  "path": "leetcode/notes/daily/2106-maximum-fruits-harvested-after-at-most-k-steps",
  "title": "2106. Maximum Fruits Harvested After at Most K Steps",
  "content": "Difficulty: Hard\n\n**Status**: **Had no idea how to solve :(**\n\n## **New Concept**: Prefix Sums:\n\nWhat: A running total of a list of numbers\n\n- EX: `amounts = [2, 5, 3, 7, 1]` has `prefix_sum = [0, 2, 7, 10, 17, 18]`\n\nWhy: Once you have the prefix sum array, you can **instantly** calculate the total amount between any two positions in the array using subtraction.\n\n**Why use a leading 0?**\n\nHelps with edge cases. The default in LC according to chat.\n\n**When to use?**\n\n- You need to query or compare values over many ranges.\n- The data is static or updated in batches.\n- Youâ€™re looking for O(1) range queries after preprocessing.\n\n## Solution \n\nConsider:\n\n`fruits = [[2,8],[6,3],[8,6]]`\n\nCan we travel from i position of fruits to j position of fruits from startPos? Answering this question for all possible i & j leads to the solution!\n\n```python\ndef maxTotalFruits(fruits, start, k):\n\tmax_fruits = 0\n\t\n\tpos = [item[0] for item in fruits]\n\tamounts = [item[1] for item in fruits]\n\tprefix_sum = [0]\n\t\n\tfor amount in amounts:\n\t\tprefix_sum.append(prefix_sum[-1] + amount)\n\n\ti = 0\n\tfor j in range(len(pos)):\n\t\tif i <= j and not canTravel(i , j):\n\t\t\ti += 1 # tighten the window size\n\t\tmax_fruits = max(max_fruits, prefix_sum[j + 1] - prefix_sum[i])\n\treturn max_fruits\n```\n\nKey Learnings:\n\n- Sliding Window doesn't always have to be from the startPos to the end position. In a problem like this where we are constrained by some cost function AND can double back, we can say:\n\t- Can we cover all the distance from some position to another position from the start position without going over the cost!\n- The key 'trick' here comes from the `canTravel` function. \n\t- From `startPos` if we want to cover the distance from `pos[i] to pos[j]` there are four ways of doing so:\n\t\t- if `pos[i]` is larger than `startPos` then all we can do is go right\n\t\t- sym. argument for `pos[j`\n\t\t- Where it gets interesting is if `pos[i] <= startPos <= pos[j]`. We can do one of two things:\n\t\t\t- Go left to `pos[i]` then go right (crossing `startPos`) to `pos[j]`\n\t\t\t- Go right to `pos[j]` then go left (crossing `startPos`) to `pos[i]`\n\t- What we want is a simple way to calculate this:\n\n```python\n# Pre: from loop cond. we have gurantee that i <= j\ndef canTravel(i, j):\n\tleft = pos[i]\n\tright = pos[j]\t\n\ttravel_distance = right - left\n\treturn min(abs(startPos - right) + travel_distance, \n\t\t\t   abs(startPos - left) + travel_distance) <= k\n```\n\n- We don't care about the path! Just whether or not we can travel it!\n\n\n",
  "metadata": {
    "date": "2026-01-16",
    "updated": "2026-01-16"
  },
  "images": [],
  "links": []
}
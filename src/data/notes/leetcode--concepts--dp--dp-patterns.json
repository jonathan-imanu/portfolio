{
  "id": "leetcode--concepts--dp--dp-patterns",
  "path": "leetcode/concepts/dp/dp-patterns",
  "title": "DP Patterns",
  "content": "The complete set of dynamic programming patterns from this [AlgoMaster Article](https://blog.algomaster.io/p/20-patterns-to-master-dynamic-programming). Some patterns, such as 18. Bitmasking DP, have been regrouped into sub-tasks within more broad patterns.\n### Aside: General Core Ideas\n\n#### Loop order defines the direction of causality in your DP.\n\nConsider [518. Coin Change II](https://leetcode.com/problems/coin-change-ii/). The problem wants the number of combinations BUT what if it asked for permutations instead? Just change the loop order:\n\n```python \n# Combinations\n# for each coin, I will use it as much as I can before moving on to the next\n# 1 + 2 is possible but 2 + 1 isn't\nfor coin in coins:\n\tfor i in range(amount):\n\t\tsome work ...\n\t\t\n# Permutations\n# from any partial sum, I may append any coin next \n# so 1 + 2 and 2 + 1 are both possible\nfor i in range(amount):\n\tfor coin in coins:\n\t\tsome work ...\n```\n## 1. Fibonacci Sequence\n\nRecap:\n\n`F(0) = 0, F(1) = 1, F(N) = F(N -1) + F(N - 2)`\n##### Example Questions\n\nFind the n^th fibonacci number.\n##### Main Idea\n\nBrute Force:\n- Use recursion to compute\n\t- **Notice**: We repeat work when doing `F(5)` and `F(4)`\nImprovement:\n- Use memorization to cache results\nAlternatively:\n- We could use **Bottom Up Dynamic Programming** to solve this\n\t- What this looks like: Have a 1D array and use compute the `i`th number based on the `i-1`th and `i-2`th until we reach `n`\n\t- How can we optimize this further? \n\t\t- **Notice**: After processing, we don't care about the stuff before the `i-2`th. So we can just have variables that track `i-1`th and `i-2`th instead!\n##### Generalize \n\n- Come up with recurrence relation\n- Memoization\n- Use array to track past states\n- Optimize further by noticing that only the last two states matter\n#### ToDos\n\n1. House Robber I - III\n\t1. [x] House Robber I\n\t2. [x] House Robber II\n\t3. [x] House Robber III\n2. Maximum Alternating Sum\n## 2. Kadane's Algorithim\n\nGiven an array, find a subarray with the maximum sum\n##### Main Idea\n\nBrute Force:\n- `O(n^2)`\n- Two for loops\nImprovement:\n- We can be greedy here, at any portion `i` we only need to determine whether it's more useful to use the sum we've computed for the contiguous array that MAY range from `0..i-1` or start fresh\n\t- The ONLY case when we'd want to start fresh is if that sum is negative\n- Why can we do this?\n\t- At every point, we should update the maximum sum we've seen so far. This allows us to the hit if necessary with the hope that we'll find larger elements beyond index `i`\n#### ToDos\n\n- A tricky one that's always worth redoing: https://leetcode.com/problems/maximum-sum-circular-subarray/description/\n## 3. 0/1 Knapsack\n\n[Video Reference](https://www.youtube.com/watch?v=nLmhmB6NzcM)\n##### Main Idea\n\nYou are given a bag with a capacity `k`. You have `n` indivisible objects with value `v` and weight `w`. You want to maximize the value of the objects that you can carry. \n- For each object, we can either include or exclude the object\n\t- Only 2 choices\n- We want to maximize profit\n\n**Brute Force:**\n- `O(2^n)` where `n` is the input size. \n- We try all possible combinations and pick the best one\n**Tabulation:**\n- We can have a matrix of size `(n + 1) x (k + 1)` where `n` is the number of indivisible objects and `k` is the capacity of the bag. Let's call this table `V`. \n- The formula to fill out this table is:\n\t- `V[i, w] = max(V[i-1, w], V[i-1, w - W[i]] + P[i])`\n\t\t- Here `W` and `P` are the arrays that have the weight and profit respectively of the `ith` item at index `i`\n\t\t- Still the \"we either take it or we don't\" idea\n- Time and Space Complexity are both `O(nk)` using the definitions from above\n### 0/1 Knapsack ToDos\n\n1. Canonical 0/1 Problems\n\t1.  ~~[416. Partition Equal Subset Sum](https://leetcode.com/problems/partition-equal-subset-sum/description/) \n\t2. ~~[474. Ones and Zeroes](https://leetcode.com/problems/ones-and-zeroes/)\n\t3. ~~[494. Target Sum](https://leetcode.com/problems/target-sum/)`\n\t4. ~~[1049. Last Stone Weight II](https://leetcode.com/problems/last-stone-weight-ii/)\n\t5. ~~[1755. Closest Subsequence Sum](https://leetcode.com/problems/closest-subsequence-sum/)\n\t\t1. This was a [Meet In The Middle](https://usaco.guide/gold/meet-in-the-middle?lang=cpp) DP Problem\n2. Counting 0/1 Knapsack\n\t1. ~~[879. Profitable Schemes](https://leetcode.com/problems/profitable-schemes/)\n\t2.  ~~[956. Tallest Billboard](https://leetcode.com/problems/tallest-billboard/)\n\t3. ~~[805. Split Array With Same Average](https://leetcode.com/problems/split-array-with-same-average/)\n\t\t1. Really hard - kinda like discrete but with dp\n\t4. ~~[1434. Number of Ways to Wear Different Hats to Each Other](https://leetcode.com/problems/number-of-ways-to-wear-different-hats-to-each-other/)\n\t\t1. Could also be considered Bitmask\n3. Knapsack with Bitmask\n\t1. ~~[1799. Maximize Score After N Operations](https://leetcode.com/problems/maximize-score-after-n-operations/)\n\t2. ~~[1986. Minimum Number of Work Sessions to Finish the Tasks](https://leetcode.com/problems/minimum-number-of-work-sessions-to-finish-the-tasks/)\n\t3. ~~[2305. Fair Distribution of Cookies](https://leetcode.com/problems/fair-distribution-of-cookies/)\n\t4. ~~[847. Shortest Path Visiting All Nodes](https://leetcode.com/problems/shortest-path-visiting-all-nodes/)\n\t5. ~~[1723. Find Minimum Time to Finish All Jobs](https://leetcode.com/problems/find-minimum-time-to-finish-all-jobs/description/)\n4. k-Way Bucket / Assignment / Partition DP\n\t1. k-Way Buckets\n\t\t1. ~~[473. Matchsticks to Square](https://leetcode.com/problems/matchsticks-to-square/description/)\n\t\t2. ~~[698. Partition to K Equal Sum Subsets](https://leetcode.com/problems/partition-to-k-equal-sum-subsets/description/)\n\t2. Group / multiple-choice knapsack (pick exactly one per group)\n\t\t1. ~~[1981. Minimize the Difference Between Target and Chosen Elements](https://leetcode.com/problems/minimize-the-difference-between-target-and-chosen-elements/description/)\n\t\t2. ~~[2218. Maximum Value of K Coins From Piles](https://leetcode.com/problems/maximum-value-of-k-coins-from-piles/description/)\n\t\t3. ~~[1155. Number of Dice Rolls With Target Sum](https://leetcode.com/problems/number-of-dice-rolls-with-target-sum/)\n\n## 4. Unbounded Knapsack\n\n1. Unbounded Knapsack\n\t1. Core unbounded (min / max / count, order-insensitive)\n\t\t1. ~~[322. Coin Change](https://leetcode.com/problems/coin-change/)\n\t\t2. ~~[518. Coin Change II](https://leetcode.com/problems/coin-change-ii/)\n\t\t3. ~~[279. Perfect Squares](https://leetcode.com/problems/perfect-squares/)\n\t\t4. ~~[1449. Form Largest Integer With Digits That Add up to Target](https://leetcode.com/problems/form-largest-integer-with-digits-that-add-up-to-target/)\n\t\t5. ~~[343. Integer Break](https://leetcode.com/problems/integer-break/)\n\t2. Unbounded counting (order matters)\n\t\t1. ~~[377. Combination Sum IV](https://leetcode.com/problems/combination-sum-iv/description/)\n\t3. Unbounded-style counting DP (not knapsack by name, same instincts)\n\t\t1. ~~[139. Word Break](https://leetcode.com/problems/word-break/)\n\t\t2. ~~[91. Decode Ways](https://leetcode.com/problems/decode-ways/)\n\n#### Knapsack Lessons\n\n**ALWAYS** iterate downward when doing dp so we don't dogfood on our own computations.\n##### 1. Canonical 0/1 Problem\n\n- Don't be so rigid in your thinking. If state transitions don't naturally arise try and rethink the states.\n\t- [416. Partition Equal Subset Sum](https://leetcode.com/problems/partition-equal-subset-sum/description/) is a good example. The state transition here is pretty logical but requires a \"reframing of the question\" and is one that goes against the approach described in the tabulation section. \n\t\t- Ignore past problems and just think about the states. Often times the naive/dfs approach will be immediately recognizable. Use that to optimize further.\n\t\t- [1049. Last Stone Weight II](https://leetcode.com/problems/last-stone-weight-ii/) is another good example.\n\t- A more general comment is to not go to deep into analyzing whether we can get `O(1)`. Code first optimize later.\n- Another good trick is replacing the dp array with a dictionary. We'll need to be careful when doing updates while iterating however -- solution is usually making and then building a new dictionary that will have the correct state info after the iteration. \n###### 1.1 Meet In The Middle DP\n\n- Traditional backtracking will TLE due to constraints (IE the `n` in `O(2^n)` is too large)\n- Break it up into two pieces of equal size and do backtracking on those smaller pieces and return the results THEN do binary search after sorting one of the returned halves.\n##### 2. Counting 0/1 Knapsack\n\n- For harder dp problems, it's important to think about state compression and how we can represent the minimal amount of information needed at each state.\n\t- A great example is 956. Tallest Billboard](https://leetcode.com/problems/tallest-billboard/). My first instinct was to have states represented by `(sum(smaller), sum(taller))`. BUT since all we care about is the `sum(smaller)` WHEN `sum(smaller) == sum(taller)` we can be creative and just store the diff `d = sum(taller) - sum(smaller)` and map it to the `sum(smaller)`\n\t\t- Why couldn't we map the difference to `sum(taller)`?  HINT: Consider state updates\n\t- Another tricky example is [805. Split Array With Same Average](https://leetcode.com/problems/split-array-with-same-average/). \n\t\t- If you think there is math involved, spend 5 minutes doing the work to verify or disprove. In this case, the optimal states become clear after doing some (not very apparent) mathematical pre-work.\n##### 3. Bitmasking DP Tip\n###### Submask Enumeration\n\nGiven a bitmask `m` we want to iterate over all submasks `s` of `m` in descending order:\n\n```python\nint s = m;\nwhile (s > 0) {\n\t...you can use s\n\ts = (s - 1) & m;\n}\n```\n\nOf course, we don't usually do this in isolation. We typically want to iterate over all masks AND their submasks. \n\n**Proof**\n\nThis has complexity `O(3^n)`:\n\nConsider the `i`-th bit there are exactly three options for it:\n- It is not included in the mask `m` and thus not in `s`\n- It is in `m` but not `s`\n- It is in both `m` & `s`\n\nFor each of the `n` bits there are 3 options for it.\n###### A Worked Example: [1723. Find Minimum Time to Finish All Jobs](https://leetcode.com/problems/find-minimum-time-to-finish-all-jobs/)\n\nWe don't need DP for this we can use backtracking by having `(current_job: int, worker_to_job_time: List[int])` as our state and then:\n- Eliminating duplication by sorting the `jobs` and stopping if we have a worker that has a job_time of 0 AFTER the backtracking work\n- Pruning states by stopping if the current max_worker_time is larger than our global max\n##### 4. 0/K DP (Partition to K Equal Subsets)\n\nTwo ways:\n1. Backtracking\n\t1. Sort the input array and track whether a number has been visited. \n\t2. Then use dfs on the array\n2. Masks\n## 5. Longest Common Subsequence (LCS)\n\n[Video Explanation](https://www.youtube.com/watch?v=NnD96abizww)\n\n**Problem**: Given two strings `s1` & `s2` what is their LCS?\n\nThis is a 2D DP problem. We can track states in the matrix `dp[n][m]` where `n = len(s1), m = len(s2)` \n\nState transitions look like:\n\n`dp[i][j + 1] = max(dp[i - 1][j + 1], dp[i][j - 1]) if s1[i] != s2[j + 1]` \n`dp[i][j + 1] = dp[i - 1][j - 1] + 1 if s1[i] == s2[j + 1]` \n- `dp[i][j + 1] = max(top, left) if s1[i] != s2[j + 1]\n- `dp[i][j + 1] == diag + 1 if s1[i] == s2[j + 1]`\n\nWhat about finding the actual LCS not just the length?\n\nStarting from `dp[n][m]` see where the value comes from, if it comes from the diagonal direction that index corresponds to a character in the LCS. This is way faster than storing the actual string LCS as a state.\n\nThe exact code looks like:\n\n```python\ni, j = n - 1, m - 1\nrev_lcs = []\nwhile i >= 0 and j >= 0:\n\ttop = dp[i - 1][j] if i - 1 > -1 else 0\n\tleft = dp[i][j - 1] if j - 1 > -1 else 0\n\tif str1[i] == str2[j]:\n\t\trev_lcs.append(str1[i])\n\t\ti -= 1\n\t\tj -= 1\n\telif top >= left:\n\t\ti -= 1\n\telse:\n\t\tj -= 1\nrev_lcs.reverse()\nlcs = \"\".join(rev_lcs)\n```\n### LCS Todos\n\n1. ~~[1143. Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/)\n2. ~~[583. Delete Operation for Two Strings](https://leetcode.com/problems/delete-operation-for-two-strings/)\n3. ~~[1092. Shortest Common Supersequence](https://leetcode.com/problems/shortest-common-supersequence/)\n4. ~~[1035. Uncrossed Lines](https://leetcode.com/problems/uncrossed-lines/)\n5. ~~[1458. Max Dot Product of Two Subsequences](https://leetcode.com/problems/max-dot-product-of-two-subsequences/)\n6. ~~[97. Interleaving String](https://leetcode.com/problems/interleaving-string/)\n\n## 6. Longest Increasing Subsequence (LIS)\n\n**Problem**: Given an array, what's the LIS?\n\nSolution can be formulated in a top-down approach where `lis[i]` represents the longest increasing subsequence ending at `i`\n\n```python\nN = len(nums)\nlis = [1] * N\nfor i in range(N - 1, -1 , -1):\n\tfor j in range(i + 1, N):\n\t\tif nums[i] < nums[j]:\n\t\t\tlis[i] = max(lis[i], lis[j] + 1)\n\treturn max(lis)\n```\n\nThis has TC `O(n^2)`\n\nWe can also this LIS with binary search in a much faster way. **TODO**\n\n1. ~~[300. Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/)\n2. ~~[673. Number of Longest Increasing Subsequence](https://leetcode.com/problems/number-of-longest-increasing-subsequence/)\n3. ~~[354. Russian Doll Envelopes](https://leetcode.com/problems/russian-doll-envelopes/)\n4. [1626. Best Team With No Conflicts](https://leetcode.com/problems/best-team-with-no-conflicts/)\n5. [1027. Longest Arithmetic Subsequence](https://leetcode.com/problems/longest-arithmetic-subsequence/)\n6. [368. Largest Divisible Subset](https://leetcode.com/problems/largest-divisible-subset/)\n\n##  7. Palindromic Subsequence\n\n6. [516. Longest Palindromic Subsequence](https://leetcode.com/problems/longest-palindromic-subsequence/)\n7. [647. Palindromic Substrings](https://leetcode.com/problems/palindromic-substrings/)\n8. [1312. Minimum Insertion Steps to Make a String Palindrome](https://leetcode.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/)\n9. [132. Palindrome Partitioning II](https://leetcode.com/problems/palindrome-partitioning-ii/)\n10. [5. Longest Palindromic Substring](https://leetcode.com/problems/longest-palindromic-substring/)\n11. [1745. Palindrome Partitioning IV](https://leetcode.com/problems/palindrome-partitioning-iv/)\n\n## 8. Edit Distance\n\n1. [72. Edit Distance](https://leetcode.com/problems/edit-distance/)\n2. [583. Delete Operation for Two Strings](https://leetcode.com/problems/delete-operation-for-two-strings/)\n3. [712. Minimum ASCII Delete Sum for Two Strings](https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/)\n4. [161. One Edit Distance](https://leetcode.com/problems/one-edit-distance/)\n5. [1035. Uncrossed Lines](https://leetcode.com/problems/uncrossed-lines/)\n6. [115. Distinct Subsequences](https://leetcode.com/problems/distinct-subsequences/)\n\n## 9. Subset Sum\n\n1. [416. Partition Equal Subset Sum](https://leetcode.com/problems/partition-equal-subset-sum/)\n2. [494. Target Sum](https://leetcode.com/problems/target-sum/)\n3. [698. Partition to K Equal Sum Subsets](https://leetcode.com/problems/partition-to-k-equal-sum-subsets/)\n4. [1049. Last Stone Weight II](https://leetcode.com/problems/last-stone-weight-ii/)\n5. [473. Matchsticks to Square](https://leetcode.com/problems/matchsticks-to-square/)\n6. [2035. Partition Array Into Two Arrays to Minimize Sum Difference](https://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/)\n\n",
  "metadata": {
    "date": "2026-01-16",
    "updated": "2026-01-16"
  },
  "images": [],
  "links": []
}
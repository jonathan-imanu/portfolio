{
  "id": "school--cscd21--lectures--week-3-consensus",
  "path": "school/cscd21/lectures/week-3-consensus",
  "title": "Week 3 - Consensus",
  "content": "##### Recap\n\n**Client**: Creates transactions using a wallet to manage cryptographic keys\n**Blockchain Node**: Ensures integrity of the blockchain by validating and forwarding transactions and blocks \n**Miner**: Creates blocks using consensus\n# Consensus\n\n## Byzantine Agreement Problem\n\nGenerals attacking a fortress must decide to attack or repeat\n- Must reach a consensus but some participants may try to sabotage this (byzantine failure)\n\nIn a fully connected network, each general could send their vote to everyone else.\n- *Failure:* Some votes might not reach their destination\n- *Sabotage:* A bad general could send different votes to different people\nSo this approach isn't resistant to byzantine failure.\n\nIn a P2P network, each general could sign and forward their vote to peers and who relay it along. This is an example of the flooding algorithm.\n- *Failure:* Some votes might not reach their destination\n- *Sabotage:* \n\t- A bad general could send different votes to different people\n\t- A bad general might not forward certain votes\nSo this approach isn't resistant to byzantine failure.\n\n## Requirements for Byzantine Fault Tolerance\n\nGiven a system of $n$ nodes, $t$ of which are dishonest. When a node $A$ broadcasts the value $x$, the other nodes are allowed to discuss with each other and verify the consistency of $A$'s broadcast, and eventually settle on a common value $y$.\n\nThe system is said to resist Byzantine faults if either:\n- $A$ is honest and all honest nodes agree that $A$ says $x$\n- $A$ fails or is dishonest and all honest nodes agree that $A$ says $Y$\n\nSecurity properties:\n- **Consistency**: Honest nodes do not contradict\n- **Liveness**: Progress is made\n## Sybil Attack \n\nIf we have a reputation system, an attacker can creates and operates multiple nodes/identities to:\n- Carry out a 51% attack to control the consensus outcome\n- Block messages from honest nodes (P2P network)\n## Proof of Work (Nakamoto Consensus)\n\n**Nonce**: Number only used once\n\nWe want to find a nonce such that `H(block)` has a certain number of leading 0s where the number of zeros is determined from the target which is reevaluated every 2016 blocks.\n- Remember `H(block) = H(merkleRoot, previous, nonce)`\n- Finding the right nonce that outputs the right hash is hard (but not impossible) to compute\n\t- Recall the properties of hashing",
  "metadata": {
    "date": "2026-01-21",
    "updated": "2026-01-21"
  },
  "images": [],
  "links": []
}